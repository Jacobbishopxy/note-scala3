# 尝一口 Scala

## Hello, World!

首先定义一个名为 `Hello.scala` 的文件：

```scala
@main def hello = println("Hello, world!")
```

接着通过 `scalac` 编译代码：

```sh
scalac Hello.scala
```

`scalac` 类似于 `javac`，它会创造以下几个文件：

```txt
Hello$package$.class
Hello$package.class
Hello$package.tasty
Hello.scala
hello.class
hello.tasty
```

现在就可以通过 `scala` 命令来执行 `hello` 方法了：

```sh
scala hello
```

打印：

```txt
Hello, world!
```

## The REPL

Scala 的 REPL（读取-求值-打印-循环）是一个命令行解释器，可作为 playground 用于测试 Scala 的代码。通过 `scala` 命令即可在你的操作系统的命令行上开启 REPL，你将看到类似这样的欢迎界面：

```sh
$ scala
Welcome to Scala 3.0.0 (OpenJDK 64-Bit Server VM, Java 11.0.9).
Type in expressions for evaluation.
Or try :help.

scala> _
```

## 变量与数据类型

### 两种类型的变量

| 变量类型 | 描述                                                                                          |
| -------- | --------------------------------------------------------------------------------------------- |
| `val`    | 创建类似于 Java 中的 `final` 不可变变量。你应总是创建 `val`，除非特殊原因必须用一个可变变量。 |
| `var`    | 创建可变变量，并且应该只在变量的内容将随时间变化时使用。                                      |

### 声明变量类型

我们可以显示的或者隐式的声明变量的类型：

```scala
val x: Int = 1  // 显式
val x = 1       // 隐式，编译器推导类型
```

第二种形式的通常被认作是类型推断，这是一种保持代码类型简洁的方式。

### 内建的数据类型

以下为数字型的数据类型：

```scala
val b: Byte = 1
val i: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0
```

Scala 的字符串与 Java 类似，但是有两个额外的特征：

- 它们支持字符串插值
- 可以更为简便的创建多行字符串

```scala
val firstName = "John"
val mi = 'C'
val lastName = "Doe"
```

可以像这样结合它们成为一个字符串，在字符串前加上 `s`，接着在变量名称前加上 `$` 符号：

```scala
println(s"Name: $firstName $mi $lastName")   // "Name: John C Doe"
```

也可以用花括号包裹它们：

```scala
println(s"2 + 2 = ${2 + 2}")   // prints "2 + 2 = 4"

val x = -1
println(s"x.abs = ${x.abs}")   // prints "x.abs = 1"
```

多行字符串：

```scala
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""
```

## 控制结构

Scala 也拥有其它语言的控制结构，同时拥有强大的 `for` 表达式以及 `match` 表达式：

- `if`/`else`
- `for` 循环和表达式
- `match` 表达式
- `while` 循环
- `try`/`catch`

### if/else

if/else 与其它语言类似：

```scala
if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")
```

也可以像这样声明一个变量：

```scala
val x = if a < b then a else b
```

贯穿整本书，所有的 scala 的控制结构都可以被用作于表达式。

一个表达式返回一个结果，而一个声明则不是。声明通常用于它们的副作用，例如使用 `println` 用于打印至控制台。

### for 循环以及表达式

`for` 关键字用于创建一个 `for` 循环。

```scala
val ints = List(1, 2, 3, 4, 5)

for i <- ints do println(i)
```

#### 守护

你可以在一个 `for` 循环中使用一个或者多个 `if` 表达式。

```scala
for
  i <- ints
  if i > 2
do
  println(i)
```

你可以使用多个生成器和守护。

```scala
for
  i <- 1 to 3
  j <- 'a' to 'c'
  if i == 2
  if j == 'b'
do
  println(s"i = $i, j = $j")   // prints: "i = 2, j = b"
```

#### for 表达式

`for` 关键字可以更强大：当你使用 `yield` 关键字而不是 `do` 所创建的 `for` 表达式，可以用于计算并产生结果。例如：

```scala
val doubles = for i <- ints yield i * 2
```

返回：

```txt
val doubles: List[Int] = List(2, 4, 6, 8, 10)
```

下面的例子让数组中所有的首字母大写：

```scala
val names = List("chris", "ed", "maurice")
val capNames = for name <- names yield name.capitalize
```

最后，`for` 表达式遍历字符串数组，返回它们各自的长度，同时长度必须大于 `4`：

```scala
val fruits = List("apple", "banana", "lime", "orange")

val fruitLengths = for
  f <- fruits
  if f.length > 4
yield
  // you can use multiple lines
  // of code here
  f.length

// fruitLengths: List[Int] = List(5, 6, 6)
```

#### match 表达式

Scala 有一个类似于 Java `switch` 的 `match` 表达式：

```scala
val i = 1

// later in the code ...
i match
  case 1 => println("one")
  case 2 => println("two")
  case _ => println("other")
```

然而 `match` 是一个表达式，这就意味着它可以通过模式匹配来返回一个结果，这样就可以绑定与一个变量：

```scala
val result = i match
  case 1 => "one"
  case 2 => "two"
  case _ => "other"
```

`match` 也可以作用于任何数据类型：

```scala
val p = Person("Fred")

// later in the code
p match
  case Person(name) if name == "Fred" =>
    println(s"$name says, Yubba dubba doo")

  case Person(name) if name == "Bam Bam" =>
    println(s"$name says, Bam bam!")

  case _ => println("Watch the Flintstones!")
```

实际上，`match` 表达式可用于根据许多不同类型的模式测试变量：

```scala
// getClassAsString is a method that takes a single argument of any type.
def getClassAsString(x: Matchable): String = x match
  case s: String => s"'$s' is a String"
  case i: Int => "Int"
  case d: Double => "Double"
  case l: List[_] => "List"
  case _ => "Unknown"

// examples
getClassAsString(1)               // Int
getClassAsString("hello")         // 'hello' is a String
getClassAsString(List(1, 2, 3))   // List
```

Scala 中还有更多模式匹配的内容。模式可以是嵌套的，模式的结果可以被绑定，甚至是允许用户定义的模式匹配。详见后面的章节。

### try/catch/finally

Scala 的 `try`/`catch`/`finally` 控制结构允许我们处理异常。类似于 Java，但是其语法与 `match` 表达式一致：

```scala
try
  writeTextToFile(text)
catch
  case ioe: IOException => println("Got an IOException.")
  case nfe: NumberFormatException => println("Got a NumberFormatException.")
finally
  println("Clean up your resources here.")
```

### while 循环

同样的 Scala 也有 `while` 循环：

```scala
while x >= 0 do x = f(x)
```

多行的 `while` 循环像是这样：

```scala
var x = 1

while
    x < 3
do
    println(x)
    x += 1
```

### 用户定义的控制结构

感谢以下这些特性：by-name parameters，infix notation，fluent interfaces，optional parentheses，extension methods，以及 higher-order functions，你可以创建你自己的控制流，这部分内容会在之后的章节中讲解到。

## Domain Modeling

Scala 同时支持函数式编程（FP）以及面向对象是编程（OOP），也支持两种范式的融合。

### 面向对象的领域模型 OOP Domain Modeling

在 OOP 风格里，封装的两个主要工具就是 traits 和 classes。

#### Traits

Scala 的 traits 可以被用作于简单的接口，但是它们仍然可以包含抽象的以及具体的方法和字段，它们可以拥有参数，如同 classes。它们提供了一种以小模块单元管理行为的方式，当需要创建具体实现时，类和对象可以从 traits 中继承，以及混合其它 traits，以便获取预期的行为。

以下例子中展示三个 traits 作为接口：

```scala
trait Speaker:
  def speak(): String  // has no body, so it’s abstract

trait TailWagger:
  def startTail(): Unit = println("tail is wagging")
  def stopTail(): Unit = println("tail is stopped")

trait Runner:
  def startRunning(): Unit = println("I’m running")
  def stopRunning(): Unit = println("Stopped running")
```

`Dog` 类可以继承所有以上的 traits，并同时实现抽象的 `speak` 方法：

```scala
class Dog(name: String) extends Speaker, TailWagger, Runner:
  def speak(): String = "Woof!"
```

同样的 `Cat` 类实现同样的 traits 并覆盖其中两个继承而来的方法：

```scala
class Cat(name: String) extends Speaker, TailWagger, Runner:
  def speak(): String = "Meow"
  override def startRunning(): Unit = println("Yeah ... I don’t run")
  override def stopRunning(): Unit = println("No need to stop")
```

那么可以这样使用这两个类：

```scala
val d = Dog("Rover")
println(d.speak())      // prints "Woof!"

val c = Cat("Morris")
println(c.speak())      // "Meow"
c.startRunning()        // "Yeah ... I don’t run"
c.stopRunning()         // "No need to stop"
```

#### Classes

Scala 的 classes 用于 OOP 风格的编程。下面是一个模型为 "person" 的类。在 OOP 中的字段通常都是可变的，因此 `firstName` 以及 `lastName` 同时以 `var` 参数进行声明：

```scala
class Person(var firstName: String, var lastName: String):
  def printFullName() = println(s"$firstName $lastName")

val p = Person("John", "Stephens")
println(p.firstName)   // "John"
p.lastName = "Legend"
p.printFullName()      // "John Legend"
```

### 函数式的领域模型 FP Domain Modeling

当你编写 FP 风格的代码是，你将用到三种结构：

- 用于定义 ADTs 的 Enums
- Case classes
- Traits

#### Enums

在 Scala 3 中，`enum` 结构是一种定义代数数据类型（ADTs）的绝佳方式。例如一个 pizza 拥有三个主要属性：

- 面饼尺寸
- 面饼类型
- 配料

这些都简单的通过枚举进行建模：

```scala
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions
```

你可以像使用一个 trait，类，或者对象那样使用枚举：

```scala
import CrustSize.*
val currentCrustSize = Small

// enums in a `match` expression
currentCrustSize match
  case Small => println("Small crust size")
  case Medium => println("Medium crust size")
  case Large => println("Large crust size")

// enums in an `if` statement
if currentCrustSize == Small then println("Small crust size")
```

另一个创建并使用 ADT 的案例：

```scala
enum Nat:
  case Zero
  case Succ(pred: Nat)
```

#### Case classes

Scala 的 `case` 类允许你通过不可变的数据类型构建一个模型。`case` 类拥有 `class` 所有的功能，以及额外的特征使得它们在函数式编程中更为有用。当编译器看到 `class` 前带有 `case` 关键字，它拥有以下效果和好处：

- case class 构造器的参数默认是公有的 `val` 字段，因此字段都是不可变的，其所有参数的访问方法都会被自动生成
- `unapply` 方法被生成，它使得你的 case classes 在 `match` 表达式上拥有更多的选择
- `copy` 方法被生成。这提供了一种方法用于创建更新后的拷贝对象，而不用修改原始对象
- `equals` 和 `hashCode` 方法被生成用于实现结构上的相等性质
- 默认的 `toString` 方法被生成，利于 debug

你可以手动的添加上述方法于一个 class，但由于上述特性在函数式编程中使用的非常广泛，因此使用 `case` 类更加方便。

以下代码解释了若干 `case` 类的特征：

```scala
// define a case class
case class Person(
  name: String,
  vocation: String
)

// create an instance of the case class
val p = Person("Reginald Kenneth Dwight", "Singer")

// a good default toString method
p                // : Person = Person(Reginald Kenneth Dwight,Singer)

// can access its fields, which are immutable
p.name           // "Reginald Kenneth Dwight"
p.name = "Joe"   // error: can’t reassign a val field

// when you need to make a change, use the `copy` method
// to “update as you copy”
val p2 = p.copy(name = "Elton John")
p2               // : Person = Person(Elton John,Singer)
```

## 方法

## 一等公民函数

## 单例对象

## Collections

## 上下文抽象 Contextual Abstractions

## 最高层定义 Toplevel Definitions

## 总结
